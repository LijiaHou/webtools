# 网络 7 层模型
### 第七层：应用层
面向用户。为软件提供接口，使得应用程序能够使用网络服务进行通信。例如超文本传输协议（HTTP）、文件传输协议（FTP）、邮件传输协议（SMTP）、域名系统（DNS）

### 第六层：表示层
表示层主要负责数据的格式转换，将应用层的信息（如文字流、图像、声音）转换为二进制的格式。如编码、加密和压缩

### 第五层：会话层
会话层时在设备之间创建被称为会话的通信通道。主要功能有：
- 会话管理
- 身份验证和授权

### 第四层：传输层
也就是TCP、UDP这层，传输层通过**分段**（Segmentation）、流量控制和差错控制来控制通信的可靠性。

传输层接收从会话层传输过来的数据，并将其分解为“段”（拆包），每个段数据单元都包含 **源端口号**、**目标端口号**和**序列号**

### 第三层：网络层
负责将上一层的数据段，从一台计算机传输到不同网络中的另一台计算机，网络层的数据单元被称为**数据包**。网络层的功能：
- **逻辑寻址**： 发送方的IP地址、目标的IP地址
- **路由**：将数据从源端移动到目标端
- **路径选择**：有多条路径可以到达目标计算机时，选择一个最佳的

### 第二层：数据链路层
负责**物理寻址**，在上一层的数据包中添加发送方和接收方的 `MAC` 地址，从而生成 **数据帧**，主要功能：
1. 将数据帧从一个节点传输到另一个节点：链路层在物理层的基础上，增加了逻辑连接的功能，确保数据能正确传输
2. 确保数据传输可靠：链路层还负责处理数据传输中出现的错误和丢失

协议：HDLC协议（点对点）、以太网协议（广播）

### 第一层：物理层
利用传输介质为链路层提供物理连接，实现比特流的透明传输。本质是负责 （0,1）比特流 与 电压高低、光的闪灭 的转换。


# http 和 https
### 1.基本概念
http: 
https:
### 2.区别和优缺点
- 安全性
- 默认端口
- 建立连接
- 缓存
- ca证书
  
# 解读 HTTP1、HTTP2
http2 相比 http1，增加了对高带宽的利用率，大幅度提高了网页的性能

## 一、发展历程
从 Http/0.9 到 Http/2 要发送多个请求，从 **多个 Tcp 连接=>keep-alive=>管道化=>多路复用** 不断的减少多次创建 Tcp 等等带来的性能损耗

## 二、http1.1 的缺陷
1. 高延迟 - 队头阻塞 (Head-Of-Line Blocking)
2. 无状态特性 - 阻碍交互
3. 明文传输 - 不安全性
4. 不支持服务端推送

### 1. 高延迟 - 队头阻塞
`队头阻塞` 指的是，当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。针对这个问题，一般的解决办法：
- `将同一页面的资源分散到不同域名下，提升链接的上限。`Chrome 有个机制，对于**同一个域名**，默认允许**同时建立 6 个** TCP 持久连接，使用持久连接虽然可以共用一个 TCP 连接，但是在**同一个管道中的同一时刻只能处理一个请求**。

  也就是说，如果对同一域名下，同时发出 10 个请求，那么只有 6 个请求可以在第一时间被处理，剩下 4 个就需要排队等待。

- `减少请求数量`
  - 使用 `雪碧图` 将多个小图合成一个大图，使用时用 js 或者 css 切割
  - 将小图`内联`到 url 里面
  - 使用 Webpack 等打包工具，将`多个 js 文件打包为 1 个`，缺点时设计不合理会导致这 1 个文件频繁改动，频繁被下载

### 2. 无状态特性 - 带来的巨大 HTTP 头部
无状态指的是，每一次的 HTTP 请求都是一个全新的请求，没有任何额外状态记录。

由于报文 Header 一般会携带 “User Agent”“Cookie”“Accept”“Server” 等许多固定的头字段，多达几百甚至上千字节。**这些过大的 `Header` 在一定程度上增加了传输成本**，以及一些重复的字段导致的浪费

### 3. 明文传输 - 不安全性
### 4. 不支持服务端推送

## 三、SPDY 协议 和 HTTP2
### 1. SPDY 协议
2009 年，谷歌公开自行研发了 SPDY 协议，主要解决了 HTTP1.x 效率不高的问题，HTTP2 也随之诞生。

|  网络结构  | 
|  ----  |
| HTTP  |
| SPDY  |
| SSL  |
| TCP  |

SPDY位于 HTTP 之下，TCP 和 SSL 之上，可轻松兼容来版本 HTTP 协议

### 2. HTTP2 简介
2015年，HTTP2 发布。HTTP2 的方法、状态码、语义和 HTTP1.x 都是一样的。HTTP2 基于 SPDY，专注与性能，最大的目标就是在用户和网站之间只用一个连接。目前很多网站已经部署了 HTTP2 （如百度图片搜索、微博主页、头条主页、掘金等），使用 HTTP2 能带来 20%~60% 的效率提升。

### 3. HTTP2 新特性
1. `二进制传输`
   - HTTP2 采用二进制格式传输，而非 HTTP1.x里的纯文本报文，二进制解析起来更高效 
   - 它把 TCP 的协议的部分特性挪到了应用层，把原来的“Header+Body” 转为小片的二进制`“帧”（Frame）`，用 “HEADERS” 帧存放头数据，用 “DATA” 帧存放实体数据
   
2. `Header 压缩`
   - HTTP2 没有使用传统的压缩算法，而是开发的专门的 “HPACK” 算法，在客户端和服务器两端建立 “字典” ，用索引号表示重复的字符串，可以达到 50% ~ 90% 的高压缩率。
3. `多路复用`
   - HTTP2 引入了多路复用技术。 
     - 同域名下所有通信都在单个连接上完成，
     - 单个连接可承担任意数量的双向数据流
     - 数据流由多个帧构成，**多个帧之间可以乱序发送**，因为可以根据帧首部的标识重新组装
4. `服务端推送`
5. `提高安全性`
   - 由于 HTTPS 是大势所趋，而且主流浏览器 Chrome、FireFox 等都宣布只支持加密的 HTTP2，所以实际应用中使用 HTTP2 都是加密的 

### 4. HTTP2 缺点
1. `TCP 以及 TCP+TLS 建立连接的延时`
2. `TCP 的队头阻塞并没有彻底解决`
3. `多路复用导致服务器压力上升`
4. `多路复用容易 Timeout`


# TCP和UDP
### 1.TCP三次握手
### 2.TCP四次挥手
### 3.TCP如何保证传输有序可靠
### 4.TCP和UDP的区别
- 可靠性
- 是否建立连接
- 单播传输

# 常见HTTP状态码
### 1xx 消息 
代表请求已接受，需要**继续**处理。属于临时的响应

- `100` Continue （继续）

### 2xx 成功 
代表请求成功被服务器处理

- `200` OK （成功）
- `204` No Content （没有内容）

### 3xx 重定向 
被请求资源已经永久移动到新的位置

- `301` Moved Permanently （永久移除）
- `302` Moved Temporarily （暂时移除）
- `304` Not Modified （未修改）
  - 命中协商缓存

这里对 301 和 302 做一下区别对比：
- **含义**：301 代表永久重定向， 302 代表临时重定向
- **缓存**：301 状态码会被浏览器缓存，下次访问相同的URL时会直接跳转到重定向的URL。302 不会被缓存，浏览器每次访问都需要重新请求服务器
- **SEO 的影响**：301 状态码对搜索引擎更友好，新的 URL 可以继承之前的 URL 的权重。302 不会转移权重。
- **URL 保留**：301 会使搜索引擎记住新的 URL，而 302 状态码不会

应用场景：
- 301 适合网站结构的调整、域名更改、URL重写等情况
- 302 适合网站维护、临时跳转等情况
  

### 4xx 请求错误 
- `400` Bad Request（错误请求）
- `401` Unauthorized（未经授权）
- `403` Forbidden（被禁止）
- `404` Not Found（找不到）
- `405` Method Not Allowed（不允许的方法）
- `408` Request Timeout（请求超时）

### 5xx 服务器错误 
- `500` Internal Server Error（内部服务器错误）
- `502` Bad Gateway（错误的网关）
- `503` Service Unavailable（服务不可用）

# HTTP跨域问题
### 1.原理
- 浏览器的同源策略
- 请求、响应、但是无法接收
- 发送Ajax请求是要受到同源策略影响的，
  而html中的 `<img>、<link>、<script>、<a>`标签都是**不受**同源策略影响

### 2.解决办法
- JSONP
  - 缺点：只 GET ，需要服务端配合返回一段 执行给定 js 函数的代码
- CORS：服务端 Access-Control-Allow-Origin 响应头
- proxy 代理
  - koa 中间件代理 koa-proxy
  - Nginx 反向代理

# http缓存
## 缓存开始时间
HTTP缓存作用于浏览器导航阶段的网络请求的**开始**时

## HTTP缓存策略

浏览器对静态资源的缓存本质上是HTTP协议的缓存策略，其中又可分为强缓存和协商缓存

### 强制缓存
通过这两个响应头字段，浏览器会缓存这一次的响应结果，再次请求此资源时会判断，如果没有过期，则直接使用缓存资源
- **Expires**
  - 指定一个**绝对时间点**。缺点是系统和服务器时间不一致会导致不准的问题（HTTP1.0）
  - 例如 
    ```
    expires: Wed, 22 Nov 2021 08:41:00 GMT
    ```
- **Cache-control**
  - 具有 max-age、no-cache(协商缓存)、no-store(不缓存) 等属性（HTTP1.1）
  - 例如
    ```js
    // 有效期是 300 s
    cache-control:max-age=300
    ```
  - 同时存在时，cache-control 优先级高于 expires


### 协商缓存
当浏览器的强缓存失效或者请求头中设置了不走强缓存，并且在第一次响应头中有 Last-Modified 或 Etag的时候，会将If-Modified-Since 和 If-None-Match 请求头到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。

- 响应头 **Last-Modified** 和 请求头 **If-Modified-Since**
- 响应头 **Etag** 和 请求头 **If-None-Match**
  -  Etag 根据文件内容生产唯一的编码，所以更精准一些
  -  两个响应头同时存在， Etag 优先级高于 Last-Modified


# Ajax
一些js中出现的请求概念
  
- Ajax
  - 全称是Asynchronous JavaScript and XML，是一种将现有技术结合起来的方法。
  - 不需要重载整个网页就能向服务端请求数据，从而更新页面数据。
  
- XMLHttpRequest
  - 是 Ajax 的核心API。
  
- Fetch 
  - 2005年以来实现的获取资源的API，是原生的，相比XMLHttpRequest，接口更灵活，
  - 而且返回Promise。目前浏览器的支持度应该是没有XHR好，但是肯定是要逐步取代Ajax的。
  
- Axios
  - 是一个基于Promise的HTTP库，可以用在浏览器和nodejs中
  
  - 特点：
    - 从浏览器中创建XMLHttpRequests
    - 从node.js中创建http请求
    - 支持Promise
    - 拦截请求和响应
    - 转换请求数据和响应数据
    - 取消请求
    - 自动转换JSON数据
    - 客户端支持防御XSRF
  
  
- http（node.js）
  - node.js环境下的发送http请求的模块，是node.js环境自带的，但是无法在浏览器环境使用。
  
#  node.js和浏览器环境的区别
  
  - 浏览器和node.js都可以看做是JS运行的平台，浏览器一般是客户端运行的环境，nodejs则是服务端
   
  - JS需要浏览器的JS引擎进行解析执行，但是不同的浏览器的JS引擎不同，存在兼容性的问题。
    
    而node.js是基于Chrome v8引擎的运行环境，可以控制版本运行，没有兼容性问题（而你无法指定客户用什么浏览器）
  
  - 也是由于各家浏览器的兼容性问题，发展也慢一些，用户升级也不统一，因此在浏览器上不得不使用比较旧的js版本，
    
    所以一般使用Babel将开发的代码转换为与ES5兼容的代码，再交付给浏览器。
    而node.js的代码则不需要这么做。
  
  - node.js使用CommonJS模块系统，而浏览器中还在使用ES模块标准
。CommonJS和esmodule是目前前端的主要模块化解决方案
    - CommonJS
      - 核心变量：exports、module.exports、require等
      - 缺点commonjs加载是同步的，必须等到相应模块加载完才执行后续代码，在nodejs中没问题，因为文件都是本地的，
        但是在浏览器中请求js文件势必会造成一些卡顿。
      - webpack会对代码中commonjs进行处理
     
    - esmodule
      - 核心变量：export、export default、import等
      - 输入的变量、函数或类时只读的
      - from后文件位置，可以使相对、绝对、模块名（可配置）
      - ...
  
  
  - 对于ECMAScript语法来说，二者都能运行。node.js中无法使用DOM和BOM操作（当然也没必要），
    
    相对的，浏览器环境也无法执行node.js中的文件操作等功能
  
  - 浏览器中this指向window对象，node.js中this指向global对象
  
  - EventLoop 也有一定的区别
  